<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON VORTEX - A Demoscene Production</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #0ff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #canvas {
            display: block;
            background: linear-gradient(135deg, #000011 0%, #001133 50%, #110022 100%);
            filter: brightness(1.1);
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            z-index: 10;
            max-width: 300px;
            line-height: 1.4;
        }
        
        #credits {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 11px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
            text-align: right;
            opacity: 0;
            transition: opacity 1s;
        }
        
        #credits.show {
            opacity: 1;
        }
        
        .glow {
            text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="info">
        <div class="glow">NEON VORTEX</div>
        <div>A Demoscene Experience</div>
        <div style="margin-top: 10px; font-size: 10px; opacity: 0.7;">
            Click to unmute audio
        </div>
    </div>
    
    <div id="credits" class="glow">
        <div>═════════════════════</div>
        <div>NEON VORTEX</div>
        <div>A Demoscene Experience</div>
        <div style="margin-top: 5px; font-size: 10px;">Year 2026</div>
        <div style="margin-top: 5px;">Concept & Code</div>
        <div style="font-size: 10px;">Pure WebGL Magic</div>
        <div style="margin-top: 5px;">Greetings to all demo lovers</div>
        <div style="margin-top: 5px;">═════════════════════</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl', { antialias: true, alpha: false });
        
        let audioContext = null;
        let audioInitialized = false;
        
        function initAudio() {
            if (audioInitialized) return;
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Resume audio context if suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            audioInitialized = true;
            generateMusic();
        }
        
        document.addEventListener('click', initAudio);
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Vertex Shader
        const vertexShader = `
            attribute vec3 position;
            attribute vec3 color;
            
            uniform mat4 projMatrix;
            uniform mat4 viewMatrix;
            uniform mat4 modelMatrix;
            
            varying vec3 vColor;
            varying float vDepth;
            
            void main() {
                vec4 worldPos = modelMatrix * vec4(position, 1.0);
                gl_Position = projMatrix * viewMatrix * worldPos;
                vColor = color;
                vDepth = gl_Position.z;
                gl_PointSize = 15.0;
            }
        `;
        
        // Fragment Shader with glow effect and point rendering
        const fragmentShader = `
            precision highp float;
            
            varying vec3 vColor;
            varying float vDepth;
            
            void main() {
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                float r = dot(cxy, cxy);
                if (r > 1.0) discard;
                
                float brightness = 1.0 - r * 0.5;
                float glow = 0.5 + 0.5 * sin(vDepth * 2.0);
                vec3 finalColor = vColor * (1.0 + glow * 0.8) * brightness;
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;
        
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }
        
        const program = gl.createProgram();
        gl.attachShader(program, compileShader(vertexShader, gl.VERTEX_SHADER));
        gl.attachShader(program, compileShader(fragmentShader, gl.FRAGMENT_SHADER));
        gl.linkProgram(program);
        
        // Get uniform locations
        const projMatrixLoc = gl.getUniformLocation(program, 'projMatrix');
        const viewMatrixLoc = gl.getUniformLocation(program, 'viewMatrix');
        const modelMatrixLoc = gl.getUniformLocation(program, 'modelMatrix');
        
        const positionLoc = gl.getAttribLocation(program, 'position');
        const colorLoc = gl.getAttribLocation(program, 'color');
        
        gl.useProgram(program);
        
        // Matrix utilities
        function createPerspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2.0);
            const nf = 1.0 / (near - far);
            
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, (2 * far * near) * nf, 0
            ];
        }
        
        function createIdentityMatrix() {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
        }
        
        function rotateMatrix(m, angle, x, y, z) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            
            const rotMat = createIdentityMatrix();
            
            if (x) {
                rotMat[5] = c; rotMat[6] = s;
                rotMat[9] = -s; rotMat[10] = c;
            } else if (y) {
                rotMat[0] = c; rotMat[2] = -s;
                rotMat[8] = s; rotMat[10] = c;
            } else if (z) {
                rotMat[0] = c; rotMat[1] = s;
                rotMat[4] = -s; rotMat[5] = c;
            }
            
            return multiplyMatrices(m, rotMat);
        }
        
        function multiplyMatrices(a, b) {
            const result = new Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i + j * 4] = 0;
                    for (let k = 0; k < 4; k++) {
                        result[i + j * 4] += a[i + k * 4] * b[k + j * 4];
                    }
                }
            }
            return result;
        }
        
        function createViewMatrix(eyeX, eyeY, eyeZ, centerX, centerY, centerZ) {
            const f = [centerX - eyeX, centerY - eyeY, centerZ - eyeZ];
            const fLen = Math.sqrt(f[0]*f[0] + f[1]*f[1] + f[2]*f[2]);
            f[0] /= fLen; f[1] /= fLen; f[2] /= fLen;
            
            const up = [0, 1, 0];
            const s = [f[1]*up[2] - f[2]*up[1], f[2]*up[0] - f[0]*up[2], f[0]*up[1] - f[1]*up[0]];
            const sLen = Math.sqrt(s[0]*s[0] + s[1]*s[1] + s[2]*s[2]);
            s[0] /= sLen; s[1] /= sLen; s[2] /= sLen;
            
            const u = [s[1]*f[2] - s[2]*f[1], s[2]*f[0] - s[0]*f[2], s[0]*f[1] - s[1]*f[0]];
            
            return [
                s[0], u[0], -f[0], 0,
                s[1], u[1], -f[1], 0,
                s[2], u[2], -f[2], 0,
                -s[0]*eyeX - s[1]*eyeY - s[2]*eyeZ,
                -u[0]*eyeX - u[1]*eyeY - u[2]*eyeZ,
                f[0]*eyeX + f[1]*eyeY + f[2]*eyeZ, 1
            ];
        }
        
        // Create particles for visual effect
        const particles = [];
        const particleCount = 8000;
        const orbitParticles = [];
        const energyBurst = [];
        const geometryLines = [];
        
        function generateParticles() {
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 5;
                const y = (Math.random() - 0.5) * 8;
                
                particles.push({
                    x: Math.cos(angle) * radius,
                    y: y,
                    z: Math.sin(angle) * radius,
                    vx: (Math.random() - 0.5) * 0.02,
                    vy: (Math.random() - 0.5) * 0.02,
                    vz: (Math.random() - 0.5) * 0.02,
                    life: Math.random(),
                    color: [
                        0.2 + Math.random() * 0.8,
                        0.1 + Math.random() * 0.9,
                        0.3 + Math.random() * 0.7
                    ]
                });
            }
        }
        
        function generateOrbitParticles() {
            for (let i = 0; i < 1500; i++) {
                const angle = Math.random() * Math.PI * 2;
                const orbitRadius = 3 + Math.random() * 4;
                const y = (Math.random() - 0.5) * 3;
                const speed = 0.015 / Math.sqrt(orbitRadius);
                
                orbitParticles.push({
                    angle: angle,
                    radius: orbitRadius,
                    y: y,
                    x: Math.cos(angle) * orbitRadius,
                    z: Math.sin(angle) * orbitRadius,
                    speed: speed,
                    color: [
                        0.1 + Math.random() * 0.9,
                        0.4 + Math.random() * 0.6,
                        0.5 + Math.random() * 0.5
                    ]
                });
            }
        }
        
        function generateGeometryLines() {
            geometryLines.length = 0;
            for (let i = 0; i < 60; i++) {
                const angle = (i / 60) * Math.PI * 2;
                const radius = 4;
                geometryLines.push({
                    x: Math.cos(angle) * radius,
                    z: Math.sin(angle) * radius,
                    y: -2 + (i % 30) * 0.15,
                    color: [0.1 + Math.sin(i * 0.1) * 0.9, 0.5 + Math.cos(i * 0.1) * 0.5, 0.8]
                });
            }
        }
        
        generateParticles();
        generateOrbitParticles();
        generateGeometryLines();
        
        // Create vertex buffers
        const positions = [];
        const colors = [];
        const indices = [];
        
        function updateBuffers() {
            positions.length = 0;
            colors.length = 0;
            indices.length = 0;
            
            // Main particles
            particles.forEach((p, i) => {
                positions.push(p.x, p.y, p.z);
                const col = p.color;
                colors.push(col[0], col[1], col[2]);
                indices.push(i);
            });
            
            // Orbit particles
            orbitParticles.forEach((p, i) => {
                positions.push(p.x, p.y, p.z);
                const col = p.color;
                colors.push(col[0], col[1], col[2]);
                indices.push(particleCount + i);
            });
            
            // Geometry lines
            geometryLines.forEach((p, i) => {
                positions.push(p.x, p.y, p.z);
                const col = p.color;
                colors.push(col[0], col[1], col[2]);
                indices.push(particleCount + orbitParticles.length + i);
            });
        }
        
        const positionBuffer = gl.createBuffer();
        const colorBuffer = gl.createBuffer();
        const indexBuffer = gl.createBuffer();
        
        gl.enableVertexAttribArray(positionLoc);
        gl.enableVertexAttribArray(colorLoc);
        
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        
        // Music generation with beat synchronization
        function generateMusic() {
            if (!audioContext) return;
            
            const now = audioContext.currentTime;
            const bpm = 120;
            const beatDuration = 60 / bpm;
            const loopDuration = beatDuration * 64;
            
            // Create multiple layers synchronized to beat
            for (let beat = 0; beat < 256; beat++) {
                const beatTime = now + (beat * beatDuration);
                const beatInPattern = beat % 64;
                
                // Powerful bassline - driving the rhythm
                const bassLine = [
                    55, 55, 82, 73,  // Bar 1
                    110, 110, 98, 110,  // Bar 2
                    82, 82, 98, 110,  // Bar 3
                    123, 110, 98, 110  // Bar 4
                ];
                const bassFrq = bassLine[beat % 16];
                playNote(bassFrq, beatTime, 0.08, beatDuration * 0.9, 'sine', 0.5);
                
                // Deep sub-bass every other beat
                if (beat % 4 === 0) {
                    playNote(bassFrq * 0.5, beatTime, 0.05, beatDuration * 1.5, 'sine', 0.35);
                }
                
                // Energetic lead melody
                if (beat % 2 === 0) {
                    const leadPattern = [
                        587, 659, 740, 880,  // Ascending
                        987, 880, 740, 880,  // Peak
                        659, 740, 880, 987,  // High section
                        1174, 987, 880, 987  // Climax
                    ];
                    const leadIdx = Math.floor(beat / 2) % 16;
                    playNote(leadPattern[leadIdx], beatTime + 0.02, 0.06, beatDuration * 0.7, 'triangle', 0.3);
                }
                
                // Harmonic pad
                if (beat % 4 === 0) {
                    const harmonyPattern = [330, 392, 440, 494, 523, 494, 440, 392];
                    const harmonyFreq = harmonyPattern[(beatInPattern / 4) % 8];
                    playNote(harmonyFreq, beatTime, 0.1, beatDuration * 1.8, 'sine', 0.25);
                }
                
                // Shimmering high notes
                if (beat % 3 === 0) {
                    const shimmerFreq = 1046 + Math.sin(beat * 0.3) * 200;
                    playNote(shimmerFreq, beatTime + 0.04, 0.05, beatDuration * 0.5, 'sine', 0.15);
                }
                
                // Kick drum with variation
                if (beat % 2 === 0) {
                    playKickDrum(beatTime, beat % 8);
                }
                
                // Snare on backbeat
                if (beat % 4 === 2) {
                    playSnare(beatTime);
                }
                
                // Hi-hat rhythm for groove
                if (beat % 1 === 0) {
                    playHiHat(beatTime, beat % 32);
                }
                
                // Spacey laser synth
                if (beat % 8 === 4) {
                    playLaserSynth(beatTime, beat);
                }
                
                // Reverse bass hits for drama
                if (beat % 16 === 0) {
                    playReverseBass(beatTime);
                }
            }
        }
        
        function playKickDrum(time, variation) {
            if (!audioContext) return;
            try {
                const osc = audioContext.createOscillator();
                const env = audioContext.createGain();
                
                // Pitch sweep for kick
                osc.frequency.setValueAtTime(200, time);
                osc.frequency.exponentialRampToValueAtTime(50, time + 0.15);
                
                env.gain.setValueAtTime(0.8, time);
                env.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                
                osc.connect(env);
                env.connect(audioContext.destination);
                
                osc.start(time);
                osc.stop(time + 0.2);
            } catch (e) {}
        }
        
        function playSnare(time) {
            if (!audioContext) return;
            try {
                const noise = audioContext.createBufferSource();
                const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.15, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < buffer.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;
                
                const env = audioContext.createGain();
                env.gain.setValueAtTime(0.6, time);
                env.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
                
                noise.connect(env);
                env.connect(audioContext.destination);
                
                noise.start(time);
                noise.stop(time + 0.15);
            } catch (e) {}
        }
        
        function playHiHat(time, pattern) {
            if (!audioContext) return;
            try {
                const noise = audioContext.createBufferSource();
                const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.08, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < buffer.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;
                
                const filter = audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 8000;
                
                const env = audioContext.createGain();
                const volume = pattern % 2 === 0 ? 0.2 : 0.1;
                env.gain.setValueAtTime(volume, time);
                env.gain.exponentialRampToValueAtTime(0.01, time + 0.08);
                
                noise.connect(filter);
                filter.connect(env);
                env.connect(audioContext.destination);
                
                noise.start(time);
                noise.stop(time + 0.08);
            } catch (e) {}
        }
        
        function playLaserSynth(time, beat) {
            if (!audioContext) return;
            try {
                const osc = audioContext.createOscillator();
                const env = audioContext.createGain();
                
                const startFreq = 800 + Math.sin(beat * 0.5) * 400;
                const endFreq = 200;
                
                osc.frequency.setValueAtTime(startFreq, time);
                osc.frequency.exponentialRampToValueAtTime(endFreq, time + 0.3);
                
                env.gain.setValueAtTime(0.4, time);
                env.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
                
                osc.connect(env);
                env.connect(audioContext.destination);
                
                osc.start(time);
                osc.stop(time + 0.3);
            } catch (e) {}
        }
        
        function playReverseBass(time) {
            if (!audioContext) return;
            try {
                const osc = audioContext.createOscillator();
                const env = audioContext.createGain();
                
                osc.frequency.setValueAtTime(100, time);
                osc.frequency.exponentialRampToValueAtTime(200, time + 0.4);
                
                env.gain.setValueAtTime(0.05, time);
                env.gain.linearRampToValueAtTime(0.5, time + 0.3);
                env.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
                
                osc.connect(env);
                env.connect(audioContext.destination);
                
                osc.start(time);
                osc.stop(time + 0.4);
            } catch (e) {}
        }
        
        function playPercussion(time, beatPos) {
            if (!audioContext) return;
            
            try {
                const osc = audioContext.createOscillator();
                const env = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.frequency.setValueAtTime(200, time);
                osc.frequency.exponentialRampToValueAtTime(40, time + 0.08);
                
                filter.type = 'highpass';
                filter.frequency.value = 100;
                
                env.gain.setValueAtTime(0.2, time);
                env.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                
                osc.connect(filter);
                filter.connect(env);
                env.connect(audioContext.destination);
                
                osc.start(time);
                osc.stop(time + 0.1);
            } catch (e) {
                // Audio context might not be ready
            }
        }
        
        function playNote(freq, time, attack, duration, waveform, volume = 0.3) {
            if (!audioContext) return;
            
            try {
                const osc = audioContext.createOscillator();
                const env = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.type = waveform;
                osc.frequency.value = freq;
                
                // Add filter for richer sound
                filter.type = 'lowpass';
                filter.frequency.value = 5000;
                filter.Q.value = 1;
                
                env.gain.setValueAtTime(0, time);
                env.gain.linearRampToValueAtTime(volume, time + attack);
                env.gain.exponentialRampToValueAtTime(0.01, time + duration);
                
                osc.connect(filter);
                filter.connect(env);
                env.connect(audioContext.destination);
                
                osc.start(time);
                osc.stop(time + duration);
            } catch (e) {
                // Audio context might not be ready
            }
        }
        
        let startTime = Date.now();
        let frameCount = 0;
        let beatPhase = 0;
        
        function animate() {
            const elapsed = (Date.now() - startTime) * 0.001;
            const bpm = 120;
            const beatDuration = 60 / bpm;
            beatPhase = (elapsed / beatDuration) % 64;
            frameCount++;
            
            // Update main particles with black hole physics
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz;
                
                const dist = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
                
                if (dist > 0.1) {
                    const gravityStrength = 0.15 / (dist * dist + 0.1);
                    const dirX = -p.x / dist;
                    const dirY = -p.y / dist;
                    const dirZ = -p.z / dist;
                    
                    p.vx += dirX * gravityStrength;
                    p.vy += dirY * gravityStrength;
                    p.vz += dirZ * gravityStrength;
                }
                
                const angle = Math.atan2(p.z, p.x);
                const xyDist = Math.sqrt(p.x*p.x + p.z*p.z);
                
                if (xyDist > 0.2) {
                    const angularForce = 0.008 * (1.0 / (xyDist + 0.5));
                    p.vx += Math.sin(angle) * angularForce * xyDist;
                    p.vz -= Math.cos(angle) * angularForce * xyDist;
                }
                
                p.vy += Math.sin(elapsed * 2 + p.life * 5) * 0.0008;
                
                const friction = Math.max(0.97, 0.985 + Math.min(0.015, dist * 0.01));
                p.vx *= friction;
                p.vy *= friction;
                p.vz *= friction;
                
                const proximityToCenter = Math.max(0, Math.min(1, (5 - dist) / 5));
                p.color[0] = 0.3 + proximityToCenter * 0.8 + 0.3 * Math.sin(elapsed + p.life);
                p.color[1] = 0.2 + (1 - proximityToCenter) * 0.8 + 0.2 * Math.cos(elapsed * 0.7);
                p.color[2] = 0.8 - proximityToCenter * 0.5 + 0.2 * Math.sin(elapsed * 1.5);
                
                const brightness = 0.8 + proximityToCenter * 0.2 + Math.sin(elapsed * 4 + p.life * 15) * 0.1;
                p.color[0] *= brightness;
                p.color[1] *= brightness;
                p.color[2] *= brightness;
            });
            
            // Update orbit particles
            orbitParticles.forEach(p => {
                p.angle += p.speed;
                p.x = Math.cos(p.angle) * p.radius;
                p.z = Math.sin(p.angle) * p.radius;
                
                const beatInfluence = Math.sin(beatPhase * Math.PI * 2 / 64) * 0.3;
                p.y += Math.sin(elapsed * 0.5 + p.radius) * 0.01 + beatInfluence * 0.02;
                
                p.color[0] = 0.2 + Math.sin(elapsed * 1.5 + p.angle) * 0.8;
                p.color[1] = 0.3 + Math.cos(elapsed * 1.2 + p.angle) * 0.7;
                p.color[2] = 0.6 + Math.sin(elapsed * 0.8 + p.angle) * 0.4;
            });
            
            // Update geometry lines with beat synchronization
            geometryLines.forEach((line, i) => {
                const beatSine = Math.sin(beatPhase * Math.PI * 2 / 64);
                const beatCos = Math.cos(beatPhase * Math.PI * 2 / 64);
                
                const baseAngle = (i / geometryLines.length) * Math.PI * 2;
                const radius = 4 + beatSine * 0.5;
                
                line.x = Math.cos(baseAngle + elapsed * 0.3) * radius;
                line.z = Math.sin(baseAngle + elapsed * 0.3) * radius;
                line.y = -2 + (i % 30) * 0.15 + beatCos * 0.3;
                
                line.color[0] = 0.3 + beatSine * 0.7;
                line.color[1] = 0.5 + beatCos * 0.5;
                line.color[2] = 0.8 + Math.sin(elapsed * 2) * 0.2;
            });
            
            updateBuffers();
            
            // Set up buffers
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.DYNAMIC_DRAW);
            gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.DYNAMIC_DRAW);
            
            // Set up matrices
            const aspect = canvas.width / canvas.height;
            const projMatrix = createPerspectiveMatrix(Math.PI / 4, aspect, 0.1, 100);
            
            const beatSine = Math.sin(beatPhase * Math.PI * 2 / 64);
            const beatCos = Math.cos(beatPhase * Math.PI * 2 / 64);
            
            const eyeDist = 5 + Math.sin(elapsed * 0.2) * 2 + beatSine * 0.5;
            const viewMatrix = createViewMatrix(
                Math.cos(elapsed * 0.2) * eyeDist + beatCos * 0.3,
                2 + Math.sin(elapsed * 0.15) * 1.5 + beatSine * 0.3,
                Math.sin(elapsed * 0.2) * eyeDist + beatCos * 0.3,
                0, 0, 0
            );
            
            let modelMatrix = createIdentityMatrix();
            modelMatrix = rotateMatrix(modelMatrix, elapsed * 0.35 + beatPhase * 0.05, 0, 1, 0);
            modelMatrix = rotateMatrix(modelMatrix, elapsed * 0.25 + beatCos * 0.1, 1, 0, 0);
            modelMatrix = rotateMatrix(modelMatrix, elapsed * 0.15 + beatSine * 0.05, 0, 0, 1);
            
            gl.uniformMatrix4fv(projMatrixLoc, false, projMatrix);
            gl.uniformMatrix4fv(viewMatrixLoc, false, viewMatrix);
            gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
            
            // Clear and draw
            gl.clearColor(0, 0, 0.08, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            gl.drawElements(gl.POINTS, indices.length, gl.UNSIGNED_SHORT, 0);
            
            // Show credits at the end
            if (elapsed > 29) {
                document.getElementById('credits').classList.add('show');
            }
            
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>
